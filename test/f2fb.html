<script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>

<style>
  body {
    margin: 0;
  }

  .video-container {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .video-container-inner {
    /* Make video to at least 100% wide and tall */
    min-width: 100%;
    min-height: 100%;

    /* Setting width & height to auto prevents the browser from stretching or squishing the video */
    width: auto;
    height: auto;

    /* Center the video */
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  .video-circle {
    position: relative;
    z-index: 1000;
    object-fit: cover;
    width: 200px;
    height: 200px;
    margin: 18px;
    border: 3px solid white;  
  }

  .fps-display {
    position: absolute;
    color: white;
    top: 10px;
    z-index: 1000;
    width: 400px;
    height:700px;
    right: 100px;
    font-size: 40px;
    background-color: brown;
    padding: 10px;
  }

  #mainvideo{
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
  }
  .ld{
    margin-top: 10px;
  }
  .cycle {
    color: white;
  }

</style>


  <div id="mainvideo"> </div>

  <div id="video-over" class="video-circle"> </div>
  <div id="stats-out" class="fps-display"> 
    <a class="cycle"  onclick="cycleResolution();" href="#">Cycle Outbound Profile</a>
    <div class='ld' id="fps-out"></div>
    <div class='ld' id="fps-in"></div>
  </div>
    
  
<canvas id="canid" width="1280" height="720" style="display:none;width:320px; height:180px;  border: 3px solid orangered;"> </canvas>

<script>

  let currProf=2;
  let landscape=false
  let profiles=[
                {width: 640, height: 360, frameRate: 24, bitrateMin: 300, bitrateMax: 600},
                {width: 960, height: 540, frameRate: 24, bitrateMin: 600, bitrateMax: 1200},
                {width: 1280, height: 720, frameRate: 24, bitrateMin: 900, bitrateMax: 1800}
               ]

  function isLandscape() {
    return (window.innerWidth>window.innerHeight);
  }

 function resizeGrid() {
  console.log("isLandscape()",isLandscape());
 }
window.addEventListener('resize',resizeGrid);

  function cycleResolution(){
    currProf++;
    if (currProf>=profiles.length){
      currProf=0;
    }
    
    localTracks.videoTrack.setEncoderConfiguration(profiles[currProf]);
    console.log('profiles[currProf]',profiles[currProf]);
    
  }

  function funk() {
    var randomColor = Math.floor(Math.random() * 16777215).toString(16);
    var canv = document.getElementById("canid");
    var ctx = document.getElementById("canid").getContext('2d');
    ctx.fillStyle = '#' + randomColor;
    ctx.beginPath();
    ctx.moveTo(Math.random() * canv.width, Math.random() * canv.height);
    ctx.lineTo(Math.random() * canv.width, Math.random() * canv.height);
    ctx.lineTo(Math.random() * canv.width, Math.random() * canv.height);
    ctx.fill();
  }
  setInterval(funk, 33);

  var localTracks = {
    videoTrack: null,
    audioTrack: null
  };

  const paramsString = document.location.search;
  const searchParams = new URLSearchParams(paramsString);
  const codec = searchParams.get("codec");
  var appid = searchParams.get("appid");
  var channel = searchParams.get("channel");

  // Custom source can't change config if starts low
  //var width=640;
  //var height=360;


  var width=1280;
  var height=720;

  if (searchParams.get("height")) {
      height = parseInt(searchParams.get("height"));
  }

  if (searchParams.get("width")) {
      width = parseInt(searchParams.get("width"));
  }

  var canv=document.getElementById("canid");
  canv.width=width;
  canv.height=height;

  var agoraClient = AgoraRTC.createClient({ mode: "rtc", codec: codec });
  var uid = null;

  async function agora() {
    agoraClient.on("user-joined", async (user) => {
      console.warn("user-joined", user);
    });

    agoraClient.on("user-published", async (user, mediaType) => {
      await agoraClient.subscribe(user, mediaType);
      if (mediaType === 'audio') {
 //       user.audioTrack.play();
      }
      else if (mediaType === 'video') {
        user.videoTrack.play("mainvideo");
      }
    });

    var stream = document.getElementById("canid").captureStream(30);
    [uid,  localTracks.audioTrack, localTracks.videoTrack] = await Promise.all([
      agoraClient.join(appid, channel, null, null),
      AgoraRTC.createMicrophoneAudioTrack(),
        AgoraRTC.createCustomVideoTrack({ mediaStreamTrack: stream.getVideoTracks()[0],  width:  profiles[currProf].width , height: profiles[currProf].height, frameRate: profiles[currProf].frameRate, bitrateMin: profiles[currProf].bitrateMin, bitrateMax: profiles[currProf].bitrateMax })
//        AgoraRTC.createCustomVideoTrack({ mediaStreamTrack: stream.getVideoTracks()[0], encoderConfig: profiles[currProf] })
      //AgoraRTC.createCameraVideoTrack({ width: { max: height }, height: { max: height }, frameRate: 30, bitrateMin: 500, bitrateMax: 1200 })
      //AgoraRTC.createCameraVideoTrack({encoderConfig: profiles[currProf] })
    ]);

    await agoraClient.publish(Object.values(localTracks));
    localTracks.videoTrack.play("video-over");

  }

  /*
  if receiving VP8 then switch to sending VP8. This should only happen for when mobile on iOS < 16

  */

  async function monitorCallStats() {
    try    
      {
        var outgoingStats = agoraClient.getLocalVideoStats();
        var fps=outgoingStats.sendFrameRate;
       /* if (fps) {
          document.getElementById("fps-out").innerHTML="FPS: "+fps;
        }*/

        await agoraClient._p2pChannel.connection.peerConnection.getStats().then(async stats => {
          await stats.forEach(report => {
              if (report.type === "inbound-rtp" && report.kind === "video") {
                // inbound fps, width, height, codec
                console.log(report);
                /*
                console.log('decoderImplementation',report["decoderImplementation"],
                'frameWidth',report["frameWidth"],
                'frameHeight',report["frameHeight"],
                'framesPerSecond',report["framesPerSecond"]);
*/  
                if (report["frameWidth"]) {
                  document.getElementById("fps-in").innerHTML="<br><u>Inbound</u><br> width: "+report["frameWidth"]+
                  " <br>height: "+report["frameHeight"]+
                  " <br>fps: "+report["framesPerSecond"]+
                  " <br>codec:  "+report["decoderImplementation"];
                }                
              }

              /*
              if (report.type === "outbound-rtp" && report.kind === "video") {

                  if (report["frameWidth"]) {
                    document.getElementById("fps-out").innerHTML="Outbound<br> width:"+report["frameWidth"]+
                    " height: "+report["frameHeight"]+
                    " fps: "+report["framesPerSecond"]+
                    " codec:  "+report["encoderImplementation"];
                  }
              }
              */              
          })
        })        
        
        if (agoraClient._p2pChannel.localTrackMap.get("videoTrack")) {
            await agoraClient._p2pChannel.connection.peerConnection.getStats(agoraClient._p2pChannel.localTrackMap.get("videoTrack").track._mediaStreamTrack).then(async stats => {
              await stats.forEach(report => {
                if (report.type === "outbound-rtp" && report.kind === "video") {
                           /*         
                  console.log('encoderImplementation',report["encoderImplementation"],
                  'qualityLimitationReason',report["qualityLimitationReason"],
                'frameWidth',report["frameWidth"],
                'frameHeight',report["frameHeight"],
                'framesPerSecond',report["framesPerSecond"]);
                */
                if (report["frameWidth"]) {
                  document.getElementById("fps-out").innerHTML="<br><u>Outbound ("+currProf+")</u><br> width: "+report["frameWidth"]+
                  "<br>height: "+report["frameHeight"]+
                  "<br>fps: "+report["framesPerSecond"]+
                  "<br>quality limit: "+report["qualityLimitationReason"]+
                  "<br>codec:  "+report["encoderImplementation"];
                }
                }
              })
            });      
          
        }
          
      } catch(e) {
        console.error(e);
      }

      setTimeout(() => {
          monitorCallStats();
      }, 500);
  }
  function run() {
    setTimeout(agora,200);
    monitorCallStats();

  }

  window.onload = run;

</script>